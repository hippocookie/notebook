# Apache Lucene
> Lucene是一个高性能、可伸缩的信息搜索(IR)库。Information Retrieval(IR) library.它使你可以为你的应用程序添加索引和搜索能力。但Lucene也仅提供搜索能力，需要根据实际使用自行完成搜索程序的其他模块（例如网页抓取、文档处理、服务器运行、用户界面和管理等）。

 人们初次解除到Lucene时，很容易将它和一些即用型程序搞混淆，比如文件搜索程序、网页搜索器以及网站搜索引擎等。其实这不是Lucene的真面目：Lucene只是一个软件类库，或者一个工具箱，而并不是一个完整的搜索程序。

 ## Lucene核心
 ### 索引过程的核心类
 ####  IndexWriter
 提供针对索引文件的写入操作，但不能用于读取或搜索索引，IndexWriter需要开率一定空间来存储索引，该功能可以由Directory完成。
 #### Directory
描述了Lucene索引的存放位置，它是一个抽象类，它的子类负责具体制定索引的存储路径。
 #### Analyzer
 文本文件在被索引之前，需要经过Analyzer（分词器）处理，它负责从被索引文本文件中提取语汇单元，并提出剩下的无用信息，如果被索引内容不是纯文本文件，那就需要先将其传唤为文本文档。
#### Document
代表一些域（Field）的集合，文档的域代表文档或者和文档相关的一些元数据。Document对象结构为一个包含多个Field对象的容器，Field是指包含能被索引的文本内容的类。
#### Field
索引中的每个文档都包含一个或多个不同命名的域，这些域包含在Field类中。

### 搜索过程的核心类
#### IndexSearcher
用于搜索由IndexWriter类创建的索引，可将其看所一个以只读方式打开索引的类，需要利用Directory实例来获取创建的索引。
#### Term
搜索功能的基本单元，与Field对象类似，Term对象包含一堆字符串元素：域名和单词，由于Term对象是由Lucene内部创建的，我们并不需要在索引阶段详细了解它们。
```java
// 搜索contents域中包含单词lucene的前10个文档，并按降序排列
Query q = new TermQuery(new Term("contents", "lucene"));
TopDocs hits = searcher.search(q, 10);
```
#### Query
Lucene含有许多具体的Query子类，如TermQuery、BooleanQuery、PhraseQuery等。
#### TermQuery
最基本的查询类型，用来指定域中包含特定项的文档。
#### TopDocs
简单的指针容器，一般指向前N个排名的搜索结果。

## 构建索引
### 搜索内容进行建模
#### 文档和域
文档时Lucene索引和搜索的原子单位，文档为包含一个或多个域的容器，而域则一次包含真正被搜索内容，每个域都有一个标识名称，该名称为一个文本值或二进制值，当你将文档加入到索引中时，可以通过一系列选项类控制Lucene的行为。

#### 灵活的架构
与数据库不同的是，Lucene没有一个确定的全局模式，也就是说，加入索引的每个文档都是独立的，它与此前加入的文档完全没有关系：它可以包含任意的域，以及任意的索引、存储和向量操作选项，它也不必包含于其他文档相同的域，甚至可以与其他文档内容相同，仅相关操作选项有所区别。

#### Denormalization
为解决文档真实结构和Lucene表示能力之间的不匹配问题，我们需要对递归文档结构进行反向规格化操作。

### 索引过程
#### 提取文本和创建文档
首先需要对索引文件，如PDF、HTML、XML等格式文件转换为Lucene可以处理的文本信息，避免索引无意义的XML元素或者HTML标签。

#### 分析文档
在索引操作时，Lucene首先分析文本，将文本数据分割成语汇单元串，然后对他们执行一些可选操作，如统一转换为小写，以进行大小写不敏感搜索，可通过调用Lucene的LowerCaseFilter类实现。通常还需调用StopFilter类从输入中去掉一些使用很频繁的无意义词（如a、an、the、in、on等）。同样也许分析输入的语汇单元，去掉他们的词干，如调用PorterStemFilter类处理英文文本。这些将原始数据转换为语汇单元，虽有用一系列filter来修正该语汇单元的操作，一起构成了分析器。

#### 向索引添加文档
对数据分析完毕后，就可以将分析结果写入索引文件中。Lucene输入数据以一种倒排索引（inverted index）的数据结构进行存储。

**索引段**
Lucene索引都包含一个或多个段，每个段都是一个独立的索引，它包含整个文档索引的一个子集。每当writer刷新缓冲区增加的文档，以及挂起目录删除操作时，索引文件都会简历一个新段，在搜索索引时，每个段都是单独访问的，但搜索结果是合并后返回的。

每个段都包含多个文件，文件格式为_X.\<ext\>，X代表段名称，\<ext>为扩展名，用来标识该文件对应索引的某个部分。如果你使用混合文件格式（Lucene默认处理方式，可通过IndexWriter.setUseCompoundFile方法进行修改），那么上述索引文件都会被压缩成一个单一的文件：_X.cfs，这种方式能在搜索期间减少打开的文件数量。

还有一个特殊文件，名叫段文件，用段_\<N>标识，该文件指向所有激活的段。Lucene会首先打开该文件，然后打开它所指向的其他文件，N被称为generation，每次提交更改时会将这个数加1。

久而久之，索引会积聚很多段，特别是当程序打开和关闭writer较为频繁时，这种情况是没问题的，IndexWriter类会周期性的选择一些段，然后将它们合并到一个新段中，删除老的段，被合并段的选取策略由一个独立的MergePolicy主导，一旦选取好这些段，具体的合并操作由MergeScheduler类实现。

## Lucene索引格式
### 多文件索引结构
#### 索引段
Lucene索引由一个或多个段（Segment）组成，而每个段由由多个索引文件组成，属于同一个段的索引文件具有相同的前缀名以及不同的后缀名。你可以把一个段看做一个子索引，尽管每个段都部署一个完全独立的索引，每个段都包含一个或多个Lucene文档，这些文档就是我们利用IndexWriter.addDocument方法添加到索引中的那些文档。

#### 增量索引
段的使用可以让你通过将文档添加到新创建的索引段中，并只需要周期性的与其他现有段合并的方法快速将新文档添加到索引中，该过程提高了效率，因为它最大限度的减少了针对物理存储的索引文件修改。

Lucne的优势之一就是支持增量索引（Incremental Indexing），该功能并不是所有信息检索库都支持的，有些信息检索库在想索引中添加新的数据时需要重新索引整个文档集合，而Lucene并不需要这样做。

段文件（segments_N）保存所有现有索引段的名称以及相关信息，每次当IndexWriter想索引提交修改之前，段文件的值都会增加。例如，当IndexWriter向索引提交修改时，它会向标识为_1的段进行写操作，挺尸删除标识为_0的段指针，以及其他未被引用的文件。

在反问索引牡蛎中任何文件之前，Lucene都会查找该文件以确认要打开和读入的索引文件。例如索引中包含标识为_2的单个段，该段的名称是存储在段文件中的，因此Lucene便只查询全追为_2的段文件。

Lucene索引以及每个段中的文件数量因索引而异，它区别于需要索引的域数量，但是每次修改索引时，索引中都会新增一个段文件以及一个segments.gen文件，其大小一致为20byte，并且该文件还包括当前新生成段的后缀名，一遍Lucene用作判断和处理最近一次索引的修改。

#### 创建一个多文件索引
由于复合文件索引结构是默认的，使用setUseCompoundFile设置false可禁止复合结构，切换到处理多文件索引结构上
```java
IndexWriterConfig config = new IndexWriterConfig(analyzer);

config.setUseCompoundFile(false);

IndexWriter indexWriter = new IndexWriter(directory, config);
```

### 复合索引结构
多文件索引结构会为每个段分别存储对应的索引文件，并且由于新文档添加到索引的同事会创建一个新段，这样做会导致索引目录大量产生各种文件，虽然多文件索引结构简单直接并且能适用于大多数场合，但是它会在索引包含很多段，或者再同一个JVM中打开多个索引的情况下产生大量的开启文件。

目前大部分的操作系统都限制系统中同事打开的文件数量，Lucene在添加一个文档的同事还会创建一个新段，并且以比较高的频率合并这些段，以减少索引文件数量，但是在执行合并过程中，索引文件数量也会临时增加，如果在索引文件数量很大的环境中使用，并且索引和搜索也在同时进行的话，这种情况下有可能会达到操作系统堆打开文件数量的设置上限。

```
-rw-r--r--   1 zongzesheng  staff   158 Jun 16 22:48 _2.fdm
-rw-r--r--   1 zongzesheng  staff   208 Jun 16 22:48 _2.fdt
-rw-r--r--   1 zongzesheng  staff    64 Jun 16 22:48 _2.fdx
-rw-r--r--   1 zongzesheng  staff   246 Jun 16 22:48 _2.fnm
-rw-r--r--   1 zongzesheng  staff    59 Jun 16 22:48 _2.nvd
-rw-r--r--   1 zongzesheng  staff   139 Jun 16 22:48 _2.nvm
-rw-r--r--   1 zongzesheng  staff   491 Jun 16 22:48 _2.si
-rw-r--r--@  1 zongzesheng  staff    93 Jun 16 22:48 _2_Lucene84_0.doc
-rw-r--r--   1 zongzesheng  staff    98 Jun 16 22:48 _2_Lucene84_0.pos
-rw-r--r--   1 zongzesheng  staff   154 Jun 16 22:48 _2_Lucene84_0.tim
-rw-r--r--   1 zongzesheng  staff    73 Jun 16 22:48 _2_Lucene84_0.tip
-rw-r--r--   1 zongzesheng  staff   225 Jun 16 22:48 _2_Lucene84_0.tmd
-rw-r--r--   1 zongzesheng  staff   318 Jun 16 22:48 segments_3
-rw-r--r--   1 zongzesheng  staff     0 Mar 24 22:49 write.lock
```
#### 复合索引文件
复合索引与多文件索引之间的唯一可见差别就是索引目录内容。复合结构把各个独立的索引文件封装在了同一个文件中，使得操作文件数量远小于多文件索引。

```bash
-rw-r--r--   1 zongzesheng  staff   352 Mar 24 22:49 _0.cfe
-rw-r--r--   1 zongzesheng  staff  1579 Mar 24 22:49 _0.cfs
-rw-r--r--   1 zongzesheng  staff   373 Mar 24 22:49 _0.si
-rw-r--r--   1 zongzesheng  staff   318 Jun 16 22:48 segments_1
-rw-r--r--   1 zongzesheng  staff     0 Mar 24 22:49 write.lock
```

### 转换索引结构
在索引期间可使用setUseCompoundFiles(boolean)方法来切换上述两种索引结构，在下次合并索引段时，Lucene会将索引转换到你指定的索引格式上来。

## 倒排索引
倒排索引就是对文档的逆向排列，在该索引中文档项处于中心地位，以每一项为起点关联包含它的文档。

### 域名（.fnm）
.fnm文件存储了段中相关文档所包含的所域名，每一个域都有一些标志位，这是在索引时会用的一些选项：
- 该域是否已被索引？
- 该域是否允许使用项向量？
- 该域是否存储norms？
- 该域是否包含有效负载？
.fnm文件中的域名排列殊勋是在索引过程中决定的，并不一定是按照字母顺序排列，每个域都根据它在文件中的顺序而被分配了一个唯一的整数标识，即域序号，与序号不是字符串类型的，它会在其他Lucene文件中使用，主要用来节省存储空间。

### 项词典（.tis,.tii）
段中所有的项（由域名和域值构成的元组）都保存在.tis文件中，项首先以域名的字母顺序排列，然后同一域的项以值得顺序排列，每个项条目都包好了它的文档频率，即段中包含该项的文档数量。


### 项频率
.frq文件包含了每个文档中的项频率。

### 项位置
.prx文件列出了文档中每个项的位置，在执行短语查询和跨度查询等操作时，就会用到位置信息。

### 域存储
当程序中请求存储讴歌域时，该域会被写入.fdx和.fdt文件。.fdt文件包含了简单的索引信息，该信息用来将该域对应得文档号保存至.fdt文件中的对应位置，.fdt文件则会存储该域的内容。

### 项向量
项向量被存储于三个文件中，.tvf文件是最大的一个，负责存储按照字母排列顺序后的特定项以及对应的项频率，硬外还有可选的项位置及其偏移量，.tvd文件会存储针对给定文档的域的项向量列表，同时还负责将该域的字节偏移量写入.tvf文件一遍需要时能检索到该域，最后.tvx文件包含有索引信息，该信息会将文档变化转换为byte格式的位置信息并存储于.tvf和.tvd文件。

### NORMS
.nrm文件包含了索引期间获取的用于表示甲醛信息的归一化因子。每个文档都在.nrm文件中战友一个字节空间，保存的内容为编码后的文档加权、域加权、基于域内容长度的归一化因子等内容的联合体。

### 文档删除
如果程序向索引文件的某个段提交了文档删除请求，那么Lucene会产生一个.del格式的文件，名称为_X_N.del，X为段名称，N为一个整数，每进行一次删除操作N都会加1。

### 基本索引操作
#### 向索引添加文档
添加文档的方法有两个：
- addDocument(Document)：使用默认分析器添加文档，该分析器在创建IndexWriter对象时指定
- addDocument(Document, Analyzer)：使用指定分析器添加文档和语汇单元操作，需要注意的是，在搜索时也需使用相同的分析器保证搜索结果正确

#### 删除索引中的文档
删除操作不会立马执行，而是放入内存缓冲区，与加入文档的操作类似，最后Lucene会通过周期性刷新文档目录来执行该操作。与加入文档一样，需调用writer的commit或close方法向索引提交更改，不过即使删除操作已完成，存储该文档的磁盘空间也不会马上释放，Lucene只是将该文档标记为删除。

提供的删除方法如下：
- deleteDocuments(Term... terms)
- deleteDocuments(Query... querys)
- deleteAll

通过Term删除单个文档，需要确认文档中都索引过对应的Field类，还需要确认所有域值都是唯一的，这样才能将这个文档单独找出来删除，否则可能会删除大量文档。

#### 更新索引中的文档
- updateDocument(Term,Document)首先删除包含Term的所有文档，然后使用writer的默认分析器添加新文档

- updateDocument(Term,Document,Analyzer)区别在于指定分析器添加文档

#### 域索引选项
- ANALYZED: 使用分析器将域值分解成独立的语汇单元流，并使语汇单元能被搜索
- NOT_ANALYZED: 对域进行索引，但不对String值进行分析，该操作实际上将域值作为单一语汇单元并使之能被搜索，是用于不能被分解的域值
- ANALYZED_NO_NORMS: 不会在索引中存储norms信息，norms记录了索引中的index-time boost信息，但是当你进行搜索时可能会比较耗费内存
- NOT_ANALYZED_NO_NORMS: 不分析，不存储norms，用于在搜索期间节省索引空间和减少内存消耗
- NO: 域值不被搜索

#### 域值存储选项
- YES: 存储域值
- NO: 不存储域值